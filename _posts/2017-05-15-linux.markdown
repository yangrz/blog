--- 

layout:     post
title:      "《深入理解计算机系统》学习笔记之链接"
subtitle:   " \"Linux\""
date:       2017-05-15 10:06:25
author:     "1r0nz"
header-img: "img/unix.jpg"
tags:
    - 基础

---

#### 前言  
  大多数编译系统提供编译驱动程序，它代表用户在需要时调用语言预处理器、编译器 、汇编器和链接器。比如 ，要用GNU编译系统构造示例程序，通过在外壳中输入下列命令行来调用GCC驱动程序。  
`unix>gcc -02 -g -o p main.c swap.c`  
具体详细的编译过程可以使用-v参数来运行GCC，下面是对应的编译指令:  
`cpp [other arguments] main.c /tmp/main.i`  
驱动程序运行C编译器（ccl），它将main.i翻译成一个ASCII汇编语言文件main.s:  
`ccl /tmp/main.i main.c -02 [other arguments] -o /tmp/main.s`  
然后，驱动程序运行汇编器（as），它将main.s翻译成一个可重定位目标文件main.o:  
`as [other arguments] -o /tmp/main.o /tmp/main.s`  
驱动程序经过相同的过程生成swap.o。最后，它运行链接器程序ld，将main.o和swap.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件p:  
`ld -o p [system object files and args] /tmp/main.o /tmp/swap.o`  
要运行可执行文件p，我们在Unix外壳的命令行上输入它的名字:  
`unix>./p`  
  
#### 目标文件  
  可重定位目标文件：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
  可执行目标文件：包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。
  共享目标文件：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器并链接。
  各个系统之间，目标文件格式不一样。老的Unix系统使用a.out格式，System V Unix早期版本使用COFF。Windows NT使用可移植可执行PE格式。现代Unix系统（如Linux，还有System V Unix后来的版本，BSD Unix以及Sun Solaris等）都使用Unix可执行和可链接ELF格式，这里重点讨论ELF格式。  

#### 可重定位目标文件  
  .text:已编译程序的机器代码。  
  .rodata:只读数据，比如printf语句中的格式串和开关语句的跳转表。  
  .data:已初始化的全局C变量。局部C变量在运行时保存在栈中，既不出现在.data:已初始化的全局C变量。局部C变量在运行时保存在栈中，既不出现在节中，也不出现在.bss节中。  
  .bss：未初始化的全局C变量。在目标文件中这个节不占据实际的空间，仅占一个占位符。  
  .symtab:一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。  
  .rel.text:一个.text节中位置的列表，当链接器把这个目标文件和其他文件结合时，需要修改这些位置。  
  .debug:一个调试符号表，其条目是程序中定义的任何全局变量的重定位信息。  
  .line:原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译驱动程序时才会得到这张表。
  .strtab:一个字符串表，其内容包含.symtab和.debug节中的符号表，以及节头部中的节名字。  
  ![ELF](http://i4.buimg.com/588926/e56500ede601a34a.png)  

#### 符号与符号表  
  函数中定义的static型变量一般不在栈中管理的。编译器在.data和.bss中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号。  